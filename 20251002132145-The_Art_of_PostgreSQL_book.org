:PROPERTIES:
:ID: 0ec0df6d-941f-40ff-9dee-bc56c521e53b
:END:
#+TITLE: The Art of PostgreSQL book

* 1. Structured Query Language (SQL)
  RDBMS (Relational DataBase Management System) and SQL are forcing developers to think in terms of data structure,
  and to declare both the data structure and the data set we want to obain
  via our queries.

  #+begin_quote
  Bad programmers worry about the code. \\
  Good programmers worry about data structures and their relationships.

  --- Linus Torvalds
  #+end_quote
** Some of the Code is Written in SQL
   The current SQL standard is SQL:2016.

   If your application is already using the SQL programming language
   and SQL engine, then as a developer it's important to fully understand how 
   much can be achieved in SQL, and what service is implemented by this runtime
   dependency in your software architecture.

   SQL is a very powerful programming language, and it is a declarative one.
   It's a wonderful tool to master, and once used properly it allows one to reduce
   both code size and the development time for new features.

** A First Use Case
   Fetch NYSE /Excel/ file and load it into a PostgreSQL table.

   How file looks:
   #+begin_example
   2010  1/4/2010    1,425,504,460  4,628,115   $38.495.460,645
   2010  1/5/2010    1,754,011,760  5,394,016   $43.932.043,406
   2010  1/6/2010    1,655,507,953  5,494,460   $43.816.749,660
   #+end_example

   #+begin_src sql 
   begin;

   drop table if exists factbook;

   create table factbook
   (
      year int,
      date date,
      shares text,
      trades text,
      dollars text
   );

   \copy factbook from 'factbook.csv' with delimiter E'\t' null ''

   alter table factbook
   alter shares
   type bigint
   using replace(shares, ',', '')::bigint,

   alter trades
   type bigint
   using replace(trades, ',', '')::bigint,

   alter dollars
   type bigint
   using substring(replace(dollars, ',', '') from 2)::numeric;

   commit;
   #+end_src


** Application Code and SQL
   Query that list all entries we have in the month of February 2017:
   #+begin_src sql
   \set start '2017-02-01'

   select date, to_char(shares, '99G999G999G999') as shares, to_char(trades, '99G999G999') as trades, to_char(dollars, 'L99G999G999G999') as dollars
   from factbook
   where date >= date :'start'
   and date < date :'start' + interval '1 month'
   order by date;
   #+end_src

   Result of the query:
   | date       | shares        | trades    | dollars          |
   |------------+---------------+-----------+------------------|
   | 2017-02-01 | 1,161,001,502 | 5,217,859 | $ 44,660,060,305 |
   | (n rows)   |               |           |                  |

   Typical implementation of that expectation in Python
   #+begin_src python
   # /// script
   # requires-python = ">=3.13"
   # dependencies = [
   #     "psycopg-binary",
   # ]
   # ///
   from datetime import date
   import sys
   import psycopg2
   import psycopg2.extras
   from calendar import Calendar

   CONNSTRING = "dbname=yesql application_name=factbook"


   def fetch_month_data(year: int, month: int) -> dict[date, tuple[str, str, str]]:
       date = "%d-%02d-01" % (year, month)
       sql = """
   select date, shared, trades, dollars
   from factbook
   where date >= date %s
   and date < date %s + interval '1 month'
   order by date;
   """
       pgconn = psycopg2.connect(CONNSTRING)
       curs = pgconn.cursor()
       curs.execute(sql, (date, date))

       return {
           date: (shares, trades, dollars)
           for (date, shares, trades, dollars) in curs.fetchall()
       }


   def list_book_for_month(year: int, month: int):
       data = fetch_month_data(year, month)
       cal = Calendar()
       print("%12s | %12s | %12s | %12s" % ("day", "shares", "trades", "dollars"))
       print("%12s-+-%12s-+-%12s-+-%12s" % ("-" * 12, "-" * 12, "-" * 12, "-" * 12))

       for day in cal.itermonthdates(year, month):
           if day.month != month:
               continue
           if day in data:
               shares, trades, dollars = data[day]
           else:
               shares, trades, dollars = 0, 0, 0
           print("%12s | %12s | %12s | %12s" % (day, shares, trades, dollars))


   if __name__ == "__main__":
       year = int(sys.argv[1])
       month = int(sys.argv[2])
       list_book_for_month(year, month)
   #+end_src

   Output when running the program
   #+begin_src sh
   $ uv run main.py 2017 2
   | day        | shares     | trades  | dollars     |
      |------------+------------+---------+-------------|
      | 2017-02-01 | 1161001502 | 5217859 | 44660060305 |
      | etc
   #+end_src
** A Word about SQL Injection
   [[https://imgs.xkcd.com/comics/exploits_of_a_mom.png]]

   It is advisable that read the documentation of current driver and understand how to send
   SQL query parameters separately from the main SQL query text;
   this is a reliable way to never have to worry about SQL injection problems ever again.

   In particular, never build a query string by concatenating query arguments directly
   into query strings, i.e. in the application client code.
   Never use library, ORM or another tooling that would do that.

   We were using the psycopg Python driver which is based on *libpq*. \\
   A lot of PostgreSQL application drivers are based on the libpq C driver, which
   implements the PostgreSQL protocols and is mantained alongside the main server's code.


** PostgreSQL protocol: server-side prepared statements
   Server-side Prepared Statements can be used in SQL thanks to the *PREPARE*
   and *EXECUTE* commands syntax:
   #+begin_src sql
   prepare foo as
   select date, shares, trades, dollars
   from factbook
   where date >= $1::date
   and date < $1::date + interval '1 month'
   order by date;

   -- And then execute the prepared statement with a parameter
   execute foo('2010-02-01') 
   #+end_src

   Remember: SQL injection happens when the SQL parser is fooled into beliving that
   a parameter string is in fact a SQL query, and then the SQL engine goes on and
   execute that SQL statement.

   *asyncpg* PostgreSQL driver that implements the PostgreSQL protocol itself, and uses
   server-side prepared statements.

   This example is now safe from SQL injection by design, because the server-side
   prepared statement protocol sends the query string and its arguments in separate protocol
   messages:
   #+begin_src python
   # /// script
   # requires-python = ">=3.13"
   # dependencies = [
   #     "asyncpg",
   # ]
   # ///
   import sys
   import asyncio
   import asyncpg
   import datetime
   from calendar import Calendar

   CONNSTRING = "postgresql://appdev@localhost/appdev?application_name=factbook"


   async def fetch_month_data(year: int, month: int):
       date = datetime.date(year, month, 1)
       sql = """
   select date, shares, trades, dollars
   from factbook
   where date >= $1::date
   and date < $1::date + interval '1 month'
   order by date;
   """
       pgconn = await asyncpg.connect(CONNSTRING)
       stmt = await pgconn.prepare(sql)
       res = {
           date: (shares, trades, dollars)
           for (date, shares, trades, dollars) in stmt.fetch(date)
       }
       await pgconn.close()
       return res


   def list_book_for_month(year: int, month: int):
       data = asyncio.run(fetch_month_data(year, month))
       cal = Calendar()
       print("%12s | %12s | %12s | %12s" % ("day", "shares", "trades", "dollars"))
       print("%12s-+-%12s-+-%12s-+-%12s" % ("-" * 12, "-" * 12, "-" * 12, "-" * 12))

       for day in cal.itermonthdates(year, month):
           if day.month != month:
               continue
           if day in data:
               shares, trades, dollars = data[day]
           else:
               shares, trades, dollars = 0, 0, 0
           print("%12s | %12s | %12s | %12s" % (day, shares, trades, dollars))


   if __name__ == "__main__":
       year = int(sys.argv[1])
       month = int(sys.argv[2])
       list_book_for_month(year, month)
   #+end_src

